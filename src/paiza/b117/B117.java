package paiza.b117;

import java.util.*;

/**
 * B117問題は教習者がコースを周りながら割り当てられた順番通りに出口を出ていき、最後に出口を出ていく教習者がコースを何周したかを求める。
 * そのため教習者を起点とし、ㇽープさせ教習者の割り当てられた順を確認して行くことで最終的に何周をしたかを計算する。
 *
 * 教習者の並んでる順をリストに保持し、ループを回しながら割り当てられた順を確認して行き、出る順の場合はリストから除去をする。
 * またループ途中、出口を過ぎたということは一周をしたことになる。
 * なので、出口をインデックス0と定めるとして、リストのインデックスが0から1に増加した場合を一周したと考えて合計周回の計算を行う。
 * 再帰ループで教習者を除去して行き、最後の一つが残った場合は必ず出口にでるため、最後の一台が残ったときはループを終了させる。
 *
 * @author kang yohan
 */

public class B117 {

    //教習車の数
    static int carNum;
    //合計周回
    static int totalAroundCnt = 0;
    //出口から出る教習者の番号(1~)
    static int order = 1;
    //並び順に教習者を格納するリスト
    static ArrayList<Integer> cars = new ArrayList<>();
    //割り当てられた順のチェックを行う教習者のインデックス
    static int carsIdx = 0;
    //教習車が出口を出たかをチェックするフラグ
    //教習車が出口を出た時は値が除去(remove())されることでインデックスを増加させなくても
    //次のチェックする値になるため出口を出た時はインデックスを増加させないようにするためのフラグ
    static boolean outFlag = false;

    public static void main(String[] args) {
        //------------------------------------------------------------
        // 入力
        //------------------------------------------------------------
        try (Scanner sc = new Scanner(System.in)) {
            //教習車の数を取得
            carNum = sc.nextInt();
            //教習者の並び順を取得
            for (int i = 0; i < carNum; i++) {
                cars.add(sc.nextInt());
            }
        }

        //------------------------------------------------------------
        // 集計
        //------------------------------------------------------------
        //合計周回を計算する
        calcTotalAroundCnt(cars);

        //------------------------------------------------------------
        // 出力
        //------------------------------------------------------------
        //合計周回を出力する
        System.out.println(totalAroundCnt);
    }

    /**
     * 合計周回を求める
     *
     * @param cars
     */
    static void calcTotalAroundCnt(ArrayList<Integer> cars) {
        //現在の教習者の割振り順をチェックする
        if (cars.get(carsIdx) == order) {
            //教習車の割振り順が出口を出る順になった場合
            cars.remove(carsIdx);
            outFlag = true;
            order++;
        }

        if (!outFlag) {
            //教習車が出口を出たとき以外はインデックスを増加させる
            if (carsIdx == 0) {
                //インデックスが0から1に増加した場合は出口を過ぎて一周をしたことと同じなため合計周回を増加させる
                totalAroundCnt++;
            }
            carsIdx++;
        }

        //carsのサイズよりインデックスが大きい場合はインデックスを0にし、再び最初からチェックを始める
        if (carsIdx >= cars.size()) {
            carsIdx = 0;
        }

        //また次のチェックのためにoutFlagをfalseに変更
        outFlag = false;

        //残りの教習車が最後一つになった場合はカウントが不要なため終了させる
        if (cars.size() <= 1) {
            return;
        }

        //残りの教習者が二つ以上の場合は再帰ループをさせ処理を持続させる
        calcTotalAroundCnt(cars);
    }
}
